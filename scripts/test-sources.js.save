// scripts/setup-environment.js
// Enhanced environment setup script for Regulatory Intelligence Platform

const fs = require('fs').promises;
const path = require('path');
const readline = require('readline');

const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout
});

const question = (prompt) => new Promise((resolve) => rl.question(prompt, resolve));

class EnvironmentSetup {
    constructor() {
        this.envFile = path.join(process.cwd(), '.env');
        this.exampleEnvFile = path.join(process.cwd(), '.env.example');
        this.config = {};
    }

    async run() {
        console.log('üéØ Regulatory Intelligence Platform - Environment Setup');
        console.log('===============================================\n');

        try {
            await this.checkExistingEnv();
            await this.gatherConfiguration();
            await this.createEnvFile();
            await this.createDirectories();
            await this.validateSetup();
            await this.showNextSteps();
        } catch (error) {
            console.error('‚ùå Setup failed:', error.message);
            process.exit(1);
        } finally {
            rl.close();
        }
    }

    async checkExistingEnv() {
        try {
            await fs.access(this.envFile);
            console.log('‚ö†Ô∏è  .env file already exists');
            const overwrite = await question('Do you want to overwrite it? (y/N): ');
            if (overwrite.toLowerCase() !== 'y') {
                console.log('Setup cancelled. Existing .env file preserved.');
                process.exit(0);
            }
        } catch {
            console.log('‚úÖ No existing .env file found, proceeding with setup...\n');
        }
    }

    async gatherConfiguration() {
        console.log('üìã Configuration Setup\n');

        // AI Service Configuration
        console.log('ü§ñ AI Analysis Service (Required)');
        console.log('The platform uses Groq AI for intelligent content analysis.');
        console.log('Get your free API key at: https://console.groq.com/\n');
        
        this.config.GROQ_API_KEY = await question('Enter your Groq API key: ');
        if (!this.config.GROQ_API_KEY.trim()) {
            throw new Error('Groq API key is required for AI analysis');
        }

        // Database Configuration
        console.log('\nüíæ Database Configuration (Optional)');
        console.log('PostgreSQL provides better performance and features.');
        console.log('Leave empty to use JSON file storage as fallback.\n');
        
        const useDatabase = await question('Do you want to configure PostgreSQL? (y/N): ');
        if (useDatabase.toLowerCase() === 'y') {
            console.log('\nEnter your PostgreSQL connection details:');
            const dbHost = await question('Host (localhost): ') || 'localhost';
            const dbPort = await question('Port (5432): ') || '5432';
            const dbName = await question('Database name (regulatory_intelligence): ') || 'regulatory_intelligence';
            const dbUser = await question('Username (postgres): ') || 'postgres';
            const dbPassword = await question('Password: ');
            
            this.config.DATABASE_URL = `postgresql://${dbUser}:${dbPassword}@${dbHost}:${dbPort}/${dbName}`;
        }

        // Server Configuration
        console.log('\nüåê Server Configuration');
        this.config.PORT = await question('Server port (3000): ') || '3000';
        this.config.NODE_ENV = await question('Environment (development): ') || 'development';

        // Optional Features
        console.log('\n‚öôÔ∏è Optional Features');
        const enableLogging = await question('Enable detailed logging? (y/N): ');
        if (enableLogging.toLowerCase() === 'y') {
            this.config.ENABLE_LOGGING = 'true';
        }

        const enableRateLimit = await question('Enable API rate limiting? (y/N): ');
        if (enableRateLimit.toLowerCase() === 'y') {
            this.config.ENABLE_RATE_LIMIT = 'true';
        }
    }

    async createEnvFile() {
        console.log('\nüìÑ Creating .env file...');

        const envContent = this.generateEnvContent();
        await fs.writeFile(this.envFile, envContent);

        console.log('‚úÖ .env file created successfully');
    }

    generateEnvContent() {
        const header = `# Regulatory Intelligence Platform - Environment Configuration
# Generated on ${new Date().toISOString()}
# 
# This file contains your environment variables. Keep it secure and never commit to version control.

`;

        const sections = [
            {
                title: '# AI Analysis Service (Required)',
                vars: {
                    'GROQ_API_KEY': this.config.GROQ_API_KEY
                }
            },
            {
                title: '# Database Configuration (Optional - falls back to JSON if not provided)',
                vars: this.config.DATABASE_URL ? {
                    'DATABASE_URL': this.config.DATABASE_URL
                } : {
                    '# DATABASE_URL': 'postgresql://user:password@localhost:5432/regulatory_intelligence'
                }
            },
            {
                title: '# Server Configuration',
                vars: {
                    'PORT': this.config.PORT,
                    'NODE_ENV': this.config.NODE_ENV
                }
            },
            {
                title: '# Optional Features',
                vars: {
                    ...(this.config.ENABLE_LOGGING && { 'ENABLE_LOGGING': this.config.ENABLE_LOGGING }),
                    ...(this.config.ENABLE_RATE_LIMIT && { 'ENABLE_RATE_LIMIT': this.config.ENABLE_RATE_LIMIT })
                }
            }
        ];

        let content = header;

        sections.forEach(section => {
            content += `${section.title}\n`;
            Object.entries(section.vars).forEach(([key, value]) => {
                content += `${key}=${value}\n`;
            });
            content += '\n';
        });

        content += `# Additional Configuration
# Uncomment and configure as needed:
# LOG_LEVEL=info
# MAX_CONNECTIONS=20
# REQUEST_TIMEOUT=30000
# CLEANUP_DAYS=90
`;

        return content;
    }

    async createDirectories() {
        console.log('\nüìÅ Creating required directories...');

        const directories = [
            'data',
            'logs',
            'scripts',
            'docs',
            'tests'
        ];

        for (const dir of directories) {
            const dirPath = path.join(process.cwd(), dir);
            try {
                await fs.mkdir(dirPath, { recursive: true });
                console.log(`‚úÖ Created directory: ${dir}/`);
            } catch (error) {
                if (error.code !== 'EEXIST') {
                    console.warn(`‚ö†Ô∏è  Could not create directory ${dir}/: ${error.message}`);
                }
            }
        }
    }

    async validateSetup() {
        console.log('\nüîç Validating setup...');

        // Validate Groq API key format
        if (!this.config.GROQ_API_KEY.startsWith('gsk_')) {
            console.warn('‚ö†Ô∏è  Warning: Groq API key format may be incorrect (should start with "gsk_")');
        }

        // Validate port
        const port = parseInt(this.config.PORT);
        if (isNaN(port) || port < 1000 || port > 65535) {
            throw new Error('Invalid port number. Must be between 1000 and 65535.');
        }

        // Test database connection if provided
        if (this.config.DATABASE_URL) {
            console.log('üîç Testing database connection...');
            try {
                const { Pool } = require('pg');
                const pool = new Pool({ connectionString: this.config.DATABASE_URL });
                const client = await pool.connect();
                await client.query('SELECT 1');
                client.release();
                await pool.end();
                console.log('‚úÖ Database connection successful');
            } catch (error) {
                console.warn(`‚ö†Ô∏è  Database connection failed: ${error.message}`);
                console.warn('The system will fall back to JSON file storage.');
            }
        }

        console.log('‚úÖ Setup validation completed');
    }

    async showNextSteps() {
        console.log('\nüéâ Setup Complete!');
        console.log('==================\n');

        console.log('Next steps:');
        console.log('1. Install dependencies: npm install');
        console.log('2. Start the server: npm run dev');
        console.log(`3. Visit: http://localhost:${this.config.PORT}`);
        console.log('4. Click "Refresh Intelligence" to fetch regulatory updates\n');

        console.log('Quick commands:');
        console.log('‚Ä¢ npm run dev          - Start development server');
        console.log('‚Ä¢ npm start            - Start production server');
        console.log('‚Ä¢ npm run refresh      - Manual intelligence refresh');
        console.log('‚Ä¢ npm run stats        - Show system statistics');
        console.log('‚Ä¢ npm test             - Run test suite\n');

        console.log('Interfaces:');
        console.log(`‚Ä¢ Main Interface:      http://localhost:${this.config.PORT}`);
        console.log(`‚Ä¢ Intelligence Dashboard: http://localhost:${this.config.PORT}/dashboard`);
        console.log(`‚Ä¢ System Diagnostics:  http://localhost:${this.config.PORT}/test`);
        console.log(`‚Ä¢ API Status:         http://localhost:${this.config.PORT}/api/system-status\n`);

        console.log('üìä The platform monitors 19 regulatory sources:');
        console.log('‚Ä¢ Primary UK: FCA, PRA, BoE, PSR, TPR');
        console.log('‚Ä¢ International: ESMA, EBA, FATF, FSB');
        console.log('‚Ä¢ Government: HM Treasury, Treasury Committee, OFSI');
        console.log('‚Ä¢ Specialist: JMLSG, Pay.UK, and more\n');

        if (!this.config.DATABASE_URL) {
            console.log('üí° Tip: For better performance, consider setting up PostgreSQL');
            console.log('   and adding DATABASE_URL to your .env file later.\n');
        }

        console.log('üîó Resources:');
        console.log('‚Ä¢ Documentation: ./docs/');
        console.log('‚Ä¢ GitHub Issues: Report bugs and request features');
        console.log('‚Ä¢ Groq Console: https://console.groq.com/ (for API key management)');
    }
}

// Run setup if called directly
if (require.main === module) {
    const setup = new EnvironmentSetup();
    setup.run().catch(error => {
        console.error('üí• Setup failed:', error.message);
        process.exit(1);
    });
}

module.exports = EnvironmentSetup;# Create the file  
nano scripts/fix-sources.js
# Copy the content from the "Quick Source Fix Script" artifact

node scripts/fix-sources.js
# Press Ctrl+C to stop current server, then:
npm run dev

// scripts/setup-environment.js
// Enhanced environment setup script for Regulatory Intelligence Platform

const fs = require('fs').promises;
const path = require('path');
const readline = require('readline');

const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout
});

const question = (prompt) => new Promise((resolve) => rl.question(prompt, resolve));

class EnvironmentSetup {
    constructor() {
        this.envFile = path.join(process.cwd(), '.env');
        this.exampleEnvFile = path.join(process.cwd(), '.env.example');
        this.config = {};
    }

    async run() {
        console.log('üéØ Regulatory Intelligence Platform - Environment Setup');
        console.log('===============================================\n');

        try {
            await this.checkExistingEnv();
            await this.gatherConfiguration();
            await this.createEnvFile();
            await this.createDirectories();
            await this.validateSetup();
            await this.showNextSteps();
        } catch (error) {
            console.error('‚ùå Setup failed:', error.message);
            process.exit(1);
        } finally {
            rl.close();
        }
    }

    async checkExistingEnv() {
        try {
            await fs.access(this.envFile);
            console.log('‚ö†Ô∏è  .env file already exists');
            const overwrite = await question('Do you want to overwrite it? (y/N): ');
            if (overwrite.toLowerCase() !== 'y') {
                console.log('Setup cancelled. Existing .env file preserved.');
                process.exit(0);
            }
        } catch {
            console.log('‚úÖ No existing .env file found, proceeding with setup...\n');
        }
    }

    async gatherConfiguration() {
        console.log('üìã Configuration Setup\n');

        // AI Service Configuration
        console.log('ü§ñ AI Analysis Service (Required)');
        console.log('The platform uses Groq AI for intelligent content analysis.');
        console.log('Get your free API key at: https://console.groq.com/\n');
        
        this.config.GROQ_API_KEY = await question('Enter your Groq API key: ');
        if (!this.config.GROQ_API_KEY.trim()) {
            throw new Error('Groq API key is required for AI analysis');
        }

        // Database Configuration
        console.log('\nüíæ Database Configuration (Optional)');
        console.log('PostgreSQL provides better performance and features.');
        console.log('Leave empty to use JSON file storage as fallback.\n');
        
        const useDatabase = await question('Do you want to configure PostgreSQL? (y/N): ');
        if (useDatabase.toLowerCase() === 'y') {
            console.log('\nEnter your PostgreSQL connection details:');
            const dbHost = await question('Host (localhost): ') || 'localhost';
            const dbPort = await question('Port (5432): ') || '5432';
            const dbName = await question('Database name (regulatory_intelligence): ') || 'regulatory_intelligence';
            const dbUser = await question('Username (postgres): ') || 'postgres';
            const dbPassword = await question('Password: ');
            
            this.config.DATABASE_URL = `postgresql://${dbUser}:${dbPassword}@${dbHost}:${dbPort}/${dbName}`;
        }

        // Server Configuration
        console.log('\nüåê Server Configuration');
        this.config.PORT = await question('Server port (3000): ') || '3000';
        this.config.NODE_ENV = await question('Environment (development): ') || 'development';

        // Optional Features
        console.log('\n‚öôÔ∏è Optional Features');
        const enableLogging = await question('Enable detailed logging? (y/N): ');
        if (enableLogging.toLowerCase() === 'y') {
            this.config.ENABLE_LOGGING = 'true';
        }

        const enableRateLimit = await question('Enable API rate limiting? (y/N): ');
        if (enableRateLimit.toLowerCase() === 'y') {
            this.config.ENABLE_RATE_LIMIT = 'true';
        }
    }

    async createEnvFile() {
        console.log('\nüìÑ Creating .env file...');

        const envContent = this.generateEnvContent();
        await fs.writeFile(this.envFile, envContent);

        console.log('‚úÖ .env file created successfully');
    }

    generateEnvContent() {
        const header = `# Regulatory Intelligence Platform - Environment Configuration
# Generated on ${new Date().toISOString()}
# 
# This file contains your environment variables. Keep it secure and never commit to version control.

`;

        const sections = [
            {
                title: '# AI Analysis Service (Required)',
                vars: {
                    'GROQ_API_KEY': this.config.GROQ_API_KEY
                }
            },
            {
                title: '# Database Configuration (Optional - falls back to JSON if not provided)',
                vars: this.config.DATABASE_URL ? {
                    'DATABASE_URL': this.config.DATABASE_URL
                } : {
                    '# DATABASE_URL': 'postgresql://user:password@localhost:5432/regulatory_intelligence'
                }
            },
            {
                title: '# Server Configuration',
                vars: {
                    'PORT': this.config.PORT,
                    'NODE_ENV': this.config.NODE_ENV
                }
            },
            {
                title: '# Optional Features',
                vars: {
                    ...(this.config.ENABLE_LOGGING && { 'ENABLE_LOGGING': this.config.ENABLE_LOGGING }),
                    ...(this.config.ENABLE_RATE_LIMIT && { 'ENABLE_RATE_LIMIT': this.config.ENABLE_RATE_LIMIT })
                }
            }
        ];

        let content = header;

        sections.forEach(section => {
            content += `${section.title}\n`;
            Object.entries(section.vars).forEach(([key, value]) => {
                content += `${key}=${value}\n`;
            });
            content += '\n';
        });

        content += `# Additional Configuration
# Uncomment and configure as needed:
# LOG_LEVEL=info
# MAX_CONNECTIONS=20
# REQUEST_TIMEOUT=30000
# CLEANUP_DAYS=90
`;

        return content;
    }

    async createDirectories() {
        console.log('\nüìÅ Creating required directories...');

        const directories = [
            'data',
            'logs',
            'scripts',
            'docs',
            'tests'
        ];

        for (const dir of directories) {
            const dirPath = path.join(process.cwd(), dir);
            try {
                await fs.mkdir(dirPath, { recursive: true });
                console.log(`‚úÖ Created directory: ${dir}/`);
            } catch (error) {
                if (error.code !== 'EEXIST') {
                    console.warn(`‚ö†Ô∏è  Could not create directory ${dir}/: ${error.message}`);
                }
            }
        }
    }

    async validateSetup() {
        console.log('\nüîç Validating setup...');

        // Validate Groq API key format
        if (!this.config.GROQ_API_KEY.startsWith('gsk_')) {
            console.warn('‚ö†Ô∏è  Warning: Groq API key format may be incorrect (should start with "gsk_")');
        }

        // Validate port
        const port = parseInt(this.config.PORT);
        if (isNaN(port) || port < 1000 || port > 65535) {
            throw new Error('Invalid port number. Must be between 1000 and 65535.');
        }

        // Test database connection if provided
        if (this.config.DATABASE_URL) {
            console.log('üîç Testing database connection...');
            try {
                const { Pool } = require('pg');
                const pool = new Pool({ connectionString: this.config.DATABASE_URL });
                const client = await pool.connect();
                await client.query('SELECT 1');
                client.release();
                await pool.end();
                console.log('‚úÖ Database connection successful');
            } catch (error) {
                console.warn(`‚ö†Ô∏è  Database connection failed: ${error.message}`);
                console.warn('The system will fall back to JSON file storage.');
            }
        }

        console.log('‚úÖ Setup validation completed');
    }

    async showNextSteps() {
        console.log('\nüéâ Setup Complete!');
        console.log('==================\n');

        console.log('Next steps:');
        console.log('1. Install dependencies: npm install');
        console.log('2. Start the server: npm run dev');
        console.log(`3. Visit: http://localhost:${this.config.PORT}`);
        console.log('4. Click "Refresh Intelligence" to fetch regulatory updates\n');

        console.log('Quick commands:');
        console.log('‚Ä¢ npm run dev          - Start development server');
        console.log('‚Ä¢ npm start            - Start production server');
        console.log('‚Ä¢ npm run refresh      - Manual intelligence refresh');
        console.log('‚Ä¢ npm run stats        - Show system statistics');
        console.log('‚Ä¢ npm test             - Run test suite\n');

        console.log('Interfaces:');
        console.log(`‚Ä¢ Main Interface:      http://localhost:${this.config.PORT}`);
        console.log(`‚Ä¢ Intelligence Dashboard: http://localhost:${this.config.PORT}/dashboard`);
        console.log(`‚Ä¢ System Diagnostics:  http://localhost:${this.config.PORT}/test`);
        console.log(`‚Ä¢ API Status:         http://localhost:${this.config.PORT}/api/system-status\n`);

        console.log('üìä The platform monitors 19 regulatory sources:');
        console.log('‚Ä¢ Primary UK: FCA, PRA, BoE, PSR, TPR');
        console.log('‚Ä¢ International: ESMA, EBA, FATF, FSB');
        console.log('‚Ä¢ Government: HM Treasury, Treasury Committee, OFSI');
        console.log('‚Ä¢ Specialist: JMLSG, Pay.UK, and more\n');

        if (!this.config.DATABASE_URL) {
            console.log('üí° Tip: For better performance, consider setting up PostgreSQL');
            console.log('   and adding DATABASE_URL to your .env file later.\n');
        }

        console.log('üîó Resources:');
        console.log('‚Ä¢ Documentation: ./docs/');
        console.log('‚Ä¢ GitHub Issues: Report bugs and request features');
        console.log('‚Ä¢ Groq Console: https://console.groq.com/ (for API key management)');
    }
}

// Run setup if called directly
if (require.main === module) {
    const setup = new EnvironmentSetup();
    setup.run().catch(error => {
        console.error('üí• Setup failed:', error.message);
        process.exit(1);
    });
}

module.exports = EnvironmentSetup;// scripts/test-sources.js
// Source testing and validation script

require('dotenv').config();
const axios = require('axios');
const Parser = require('rss-parser');
const cheerio = require('cheerio');

class SourceTester {
    constructor() {
        this.parser = new Parser({
            timeout: 10000,
            headers: {
                'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
            }
        });
        this.results = {
            rss: [],
            websites: [],
            summary: {}
        };
    }

    async testAllSources() {
        console.log('üîç Testing All Regulatory Sources');
        console.log('=================================\n');

        try {
            await this.testRSSFeeds();
            await this.testWebsites();
            this.generateSummary();
            this.showResults();
            this.showRecommendations();
        } catch (error) {
            console.error('‚ùå Testing failed:', error.message);
        }
    }

    async testRSSFeeds() {
        console.log('üì° Testing RSS Feeds...\n');

        const rssFeeds = [
            { name: 'FCA', url: 'https://www.fca.org.uk/news/rss.xml' },
            { name: 'BoE', url: 'https://www.bankofengland.co.uk/news/rss' },
            { name: 'PRA', url: 'https://www.bankofengland.co.uk/prudential-regulation/publication/rss' },
            { name: 'Treasury Committee', url: 'https://committees.parliament.uk/rss/158/publications.xml' },
            { name: 'ESMA', url: 'https://www.esma.europa.eu/rss.xml' },
            { name: 'EBA', url: 'https://www.eba.europa.eu/news-press/rss.xml' },
            { name: 'FSB', url: 'https://www.fsb.org/feed/' }
        ];

        for (const feed of rssFeeds) {
            await this.testRSSFeed(feed);
        }
    }

    async testRSSFeed(feed) {
        try {
            console.log(`üîç Testing ${feed.name}...`);
            
            const startTime = Date.now();
            const parsedFeed = await this.parser.parseURL(feed.url);
            const responseTime = Date.now() - startTime;
            
            const result = {
                name: feed.name,
                url: feed.url,
                status: 'success',
                responseTime: `${responseTime}ms`,
                itemCount: parsedFeed.items.length,
                title: parsedFeed.title,
                lastBuildDate: parsedFeed.lastBuildDate,
                recentItems: parsedFeed.items.slice(0, 3).map(item => ({
                    title: item.title?.substring(0, 60) + '...',
                    date: item.pubDate
                }))
            };
            
            this.results.rss.push(result);
            console.log(`‚úÖ ${feed.name}: ${parsedFeed.items.length} items (${responseTime}ms)`);
            
        } catch (error) {
            const result = {
                name: feed.name,
                url: feed.url,
                status: 'failed',
                error: error.message,
                suggestion: this.getSuggestionForError(error.message)
            };
            
            this.results.rss.push(result);
            console.log(`‚ùå ${feed.name}: ${error.message}`);
        }
    }

    async testWebsites() {
        console.log('\nüï∑Ô∏è Testing Website Sources...\n');

        const websites = [
            { name: 'FCA Publications', url: 'https://www.fca.org.uk/publications' },
            { name: 'PSR News', url: 'https://www.psr.org.uk/news-and-updates/latest-news/' },
            { name: 'TPR Press Releases', url: 'https://www.thepensionsregulator.gov.uk/en/media-hub/press-releases' },
            { name: 'SFO News', url: 'https://www.sfo.gov.uk/news-and-publications/news/' },
            { name: 'HM Treasury', url: 'https://www.gov.uk/search/news-and-communications?organisations[]=hm-treasury' },
            { name: 'FATF Publications', url: 'https://www.fatf-gafi.org/en/publications.html' },
            { name: 'OFSI Updates', url: 'https://www.gov.uk/search/news-and-communications?organisations[]=office-of-financial-sanctions-implementation' },
            { name: 'Pay.UK News', url: 'https://www.wearepay.uk/news/' },
            { name: 'JMLSG Updates', url: 'https://www.jmlsg.org.uk/news/' }
        ];

        for (const site of websites) {
            await this.testWebsite(site);
        }
    }

    async testWebsite(site) {
        try {
            console.log(`üîç Testing ${site.name}...`);
            
            const startTime = Date.now();
            const response = await axios.get(site.url, {
                headers: { 
                    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
                },
                timeout: 10000
            });
            const responseTime = Date.now() - startTime;
            
            const $ = cheerio.load(response.data);
            
            // Test common selectors
            const selectors = [
                'article', '.news-item', '.content-item', '.publication-item',
                '.press-release', '.views-row', '.gem-c-document-list__item'
            ];
            
            let bestSelector = null;
            let maxItems = 0;
            
            for (const selector of selectors) {
                const items = $(selector);
                if (items.length > maxItems) {
                    maxItems = items.length;
                    bestSelector = selector;
                }
            }
            
            const result = {
                name: site.name,
                url: site.url,
                status: 'success',
                responseTime: `${responseTime}ms`,
                statusCode: response.status,
                bestSelector,
                itemCount: maxItems,
                contentLength: response.data.length
            };
            
            this.results.websites.push(result);
            console.log(`‚úÖ ${site.name}: ${maxItems} items found with '${bestSelector}' (${responseTime}ms)`);
            
        } catch (error) {
            const result = {
                name: site.name,
                url: site.url,
                status: 'failed',
                error: error.message,
                statusCode: error.response?.status,
                suggestion: this.getSuggestionForError(error.message, error.response?.status)
            };
            
            this.results.websites.push(result);
            console.log(`‚ùå ${site.name}: ${error.response?.status || 'Error'} - ${error.message}`);
        }
    }

    getSuggestionForError(errorMessage, statusCode) {
        if (statusCode === 404) {
            return 'URL may have changed - check the website for updated RSS/news URLs';
        }
        if (statusCode === 403) {
            return 'Website blocking automated requests - may need user-agent headers or rate limiting';
        }
        if (errorMessage.includes('timeout')) {
            return 'Increase timeout or check network connectivity';
        }
        if (errorMessage.includes('ENOTFOUND')) {
            return 'DNS resolution failed - check if domain exists';
        }
        return 'Check URL and network connectivity';
    }

    generateSummary() {
        const rssSuccess = this.results.rss.filter(r => r.status === 'success').length;
        const rssTotal = this.results.rss.length;
        const websiteSuccess = this.results.websites.filter(r => r.status === 'success').length;
        const websiteTotal = this.results.websites.length;
        
        this.results.summary = {
            rss: { success: rssSuccess, total: rssTotal, rate: Math.round((rssSuccess/rssTotal) * 100) },
            websites: { success: websiteSuccess, total: websiteTotal, rate: Math.round((websiteSuccess/websiteTotal) * 100) },
            overall: { 
                success: rssSuccess + websiteSuccess, 
                total: rssTotal + websiteTotal,
                rate: Math.round(((rssSuccess + websiteSuccess)/(rssTotal + websiteTotal)) * 100)
            }
        };
    }

    showResults() {
        console.log('\nüìä TEST RESULTS SUMMARY');
        console.log('=======================\n');
        
        const { summary } = this.results;
        
        console.log(`ÔøΩÔøΩ RSS Feeds: ${summary.rss.success}/${summary.rss.total} working (${summary.rss.rate}%)`);
        console.log(`üï∑Ô∏è Websites: ${summary.websites.success}/${summary.websites.total} working (${summary.websites.rate}%)`);
        console.log(`üéØ Overall: ${summary.overall.success}/${summary.overall.total} sources working (${summary.overall.rate}%)\n`);
        
        // Show failed sources
        const failedRSS = this.results.rss.filter(r => r.status === 'failed');
        const failedWebsites = this.results.websites.filter(r => r.status === 'failed');
        
        if (failedRSS.length > 0) {
            console.log('‚ùå Failed RSS Feeds:');
            failedRSS.forEach(feed => {
                console.log(`   ‚Ä¢ ${feed.name}: ${feed.error}`);
                if (feed.suggestion) {
                    console.log(`     üí° ${feed.suggestion}`);
                }
            });
            console.log();
        }
        
        if (failedWebsites.length > 0) {
            console.log('‚ùå Failed Websites:');
            failedWebsites.forEach(site => {
                console.log(`   ‚Ä¢ ${site.name}: ${site.statusCode || 'Error'} - ${site.error}`);
                if (site.suggestion) {
                    console.log(`     üí° ${site.suggestion}`);
                }
            });
            console.log();
        }
    }

    showRecommendations() {
        console.log('ÔøΩÔøΩ RECOMMENDATIONS');
        console.log('==================\n');
        
        const { summary } = this.results;
        
        if (summary.overall.rate >= 80) {
            console.log('‚úÖ Source connectivity is excellent! Most sources are working properly.');
        } else if (summary.overall.rate >= 60) {
            console.log('‚ö†Ô∏è Source connectivity is fair. Some sources need attention.');
        } else {
            console.log('üî¥ Multiple source issues detected. Review and update source configurations.');
        }
        
        console.log('\nüìã Next Steps:');
        console.log('1. Update URLs for failed RSS feeds in src/services/rssFetcher.js');
        console.log('2. Update selectors for failed websites in getScrapingSources()');
        console.log('3. Test individual sources: node scripts/test-sources.js');
        console.log('4. Run a refresh: npm run refresh');
        
        console.log('\nüí° Tips:');
        console.log('‚Ä¢ For 404 errors: Check if the URL has changed on the website');
        console.log('‚Ä¢ For 403 errors: The site may be blocking automated requests');
        console.log('‚Ä¢ For timeout errors: Increase timeout or check network');
        console.log('‚Ä¢ Some sites change their structure - selectors may need updating');
    }
}

// Run test if called directly
if (require.main === module) {
    const tester = new SourceTester();
    tester.testAllSources().catch(error => {
        console.error('üí• Source testing failed:', error.message);
        process.exit(1);
    });
}

module.exports = SourceTester;// scripts/test-sources.js
// Source testing and validation script

require('dotenv').config();
const axios = require('axios');
const Parser = require('rss-parser');
const cheerio = require('cheerio');

class SourceTester {
    constructor() {
        this.parser = new Parser({
            timeout: 10000,
            headers: {
                'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
            }
        });
        this.results = {
            rss: [],
            websites: [],
            summary: {}
        };
    }

    async testAllSources() {
        console.log('üîç Testing All Regulatory Sources');
        console.log('=================================\n');

        try {
            await this.testRSSFeeds();
            await this.testWebsites();
            this.generateSummary();
            this.showResults();
            this.showRecommendations();
        } catch (error) {
            console.error('‚ùå Testing failed:', error.message);
        }
    }

    async testRSSFeeds() {
        console.log('üì° Testing RSS Feeds...\n');

        const rssFeeds = [
            { name: 'FCA', url: 'https://www.fca.org.uk/news/rss.xml' },
            { name: 'BoE', url: 'https://www.bankofengland.co.uk/news/rss' },
            { name: 'PRA', url: 'https://www.bankofengland.co.uk/prudential-regulation/publication/rss' },
            { name: 'Treasury Committee', url: 'https://committees.parliament.uk/rss/158/publications.xml' },
            { name: 'ESMA', url: 'https://www.esma.europa.eu/rss.xml' },
            { name: 'EBA', url: 'https://www.eba.europa.eu/news-press/rss.xml' },
            { name: 'FSB', url: 'https://www.fsb.org/feed/' }
        ];

        for (const feed of rssFeeds) {
            await this.testRSSFeed(feed);
        }
    }

    async testRSSFeed(feed) {
        try {
            console.log(`üîç Testing ${feed.name}...`);
            
            const startTime = Date.now();
            const parsedFeed = await this.parser.parseURL(feed.url);
            const responseTime = Date.now() - startTime;
            
            const result = {
                name: feed.name,
                url: feed.url,
                status: 'success',
                responseTime: `${responseTime}ms`,
                itemCount: parsedFeed.items.length,
                title: parsedFeed.title,
                lastBuildDate: parsedFeed.lastBuildDate,
                recentItems: parsedFeed.items.slice(0, 3).map(item => ({
                    title: item.title?.substring(0, 60) + '...',
                    date: item.pubDate
                }))
            };
            
            this.results.rss.push(result);
            console.log(`‚úÖ ${feed.name}: ${parsedFeed.items.length} items (${responseTime}ms)`);
            
        } catch (error) {
            const result = {
                name: feed.name,
                url: feed.url,
                status: 'failed',
                error: error.message,
                suggestion: this.getSuggestionForError(error.message)
            };
            
            this.results.rss.push(result);
            console.log(`‚ùå ${feed.name}: ${error.message}`);
        }
    }

    async testWebsites() {
        console.log('\nüï∑Ô∏è Testing Website Sources...\n');

        const websites = [
            { name: 'FCA Publications', url: 'https://www.fca.org.uk/publications' },
            { name: 'PSR News', url: 'https://www.psr.org.uk/news-and-updates/latest-news/' },
            { name: 'TPR Press Releases', url: 'https://www.thepensionsregulator.gov.uk/en/media-hub/press-releases' },
            { name: 'SFO News', url: 'https://www.sfo.gov.uk/news-and-publications/news/' },
            { name: 'HM Treasury', url: 'https://www.gov.uk/search/news-and-communications?organisations[]=hm-treasury' },
            { name: 'FATF Publications', url: 'https://www.fatf-gafi.org/en/publications.html' },
            { name: 'OFSI Updates', url: 'https://www.gov.uk/search/news-and-communications?organisations[]=office-of-financial-sanctions-implementation' },
            { name: 'Pay.UK News', url: 'https://www.wearepay.uk/news/' },
            { name: 'JMLSG Updates', url: 'https://www.jmlsg.org.uk/news/' }
        ];

        for (const site of websites) {
            await this.testWebsite(site);
        }
    }

    async testWebsite(site) {
        try {
            console.log(`üîç Testing ${site.name}...`);
            
            const startTime = Date.now();
            const response = await axios.get(site.url, {
                headers: { 
                    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
                },
                timeout: 10000
            });
            const responseTime = Date.now() - startTime;
            
            const $ = cheerio.load(response.data);
            
            // Test common selectors
            const selectors = [
                'article', '.news-item', '.content-item', '.publication-item',
                '.press-release', '.views-row', '.gem-c-document-list__item'
            ];
            
            let bestSelector = null;
            let maxItems = 0;
            
            for (const selector of selectors) {
                const items = $(selector);
                if (items.length > maxItems) {
                    maxItems = items.length;
                    bestSelector = selector;
                }
            }
            
            const result = {
                name: site.name,
                url: site.url,
                status: 'success',
                responseTime: `${responseTime}ms`,
                statusCode: response.status,
                bestSelector,
                itemCount: maxItems,
                contentLength: response.data.length
            };
            
            this.results.websites.push(result);
            console.log(`‚úÖ ${site.name}: ${maxItems} items found with '${bestSelector}' (${responseTime}ms)`);
            
        } catch (error) {
            const result = {
                name: site.name,
                url: site.url,
                status: 'failed',
                error: error.message,
                statusCode: error.response?.status,
                suggestion: this.getSuggestionForError(error.message, error.response?.status)
            };
            
            this.results.websites.push(result);
            console.log(`‚ùå ${site.name}: ${error.response?.status || 'Error'} - ${error.message}`);
        }
    }

    getSuggestionForError(errorMessage, statusCode) {
        if (statusCode === 404) {
            return 'URL may have changed - check the website for updated RSS/news URLs';
        }
        if (statusCode === 403) {
            return 'Website blocking automated requests - may need user-agent headers or rate limiting';
        }
        if (errorMessage.includes('timeout')) {
            return 'Increase timeout or check network connectivity';
        }
        if (errorMessage.includes('ENOTFOUND')) {
            return 'DNS resolution failed - check if domain exists';
        }
        return 'Check URL and network connectivity';
    }

    generateSummary() {
        const rssSuccess = this.results.rss.filter(r => r.status === 'success').length;
        const rssTotal = this.results.rss.length;
        const websiteSuccess = this.results.websites.filter(r => r.status === 'success').length;
        const websiteTotal = this.results.websites.length;
        
        this.results.summary = {
            rss: { success: rssSuccess, total: rssTotal, rate: Math.round((rssSuccess/rssTotal) * 100) },
            websites: { success: websiteSuccess, total: websiteTotal, rate: Math.round((websiteSuccess/websiteTotal) * 100) },
            overall: { 
                success: rssSuccess + websiteSuccess, 
                total: rssTotal + websiteTotal,
                rate: Math.round(((rssSuccess + websiteSuccess)/(rssTotal + websiteTotal)) * 100)
            }
        };
    }

    showResults() {
        console.log('\nüìä TEST RESULTS SUMMARY');
        console.log('=======================\n');
        
        const { summary } = this.results;
        
        console.log(`ÔøΩÔøΩ RSS Feeds: ${summary.rss.success}/${summary.rss.total} working (${summary.rss.rate}%)`);
        console.log(`üï∑Ô∏è Websites: ${summary.websites.success}/${summary.websites.total} working (${summary.websites.rate}%)`);
        console.log(`üéØ Overall: ${summary.overall.success}/${summary.overall.total} sources working (${summary.overall.rate}%)\n`);
        
        // Show failed sources
        const failedRSS = this.results.rss.filter(r => r.status === 'failed');
        const failedWebsites = this.results.websites.filter(r => r.status === 'failed');
        
        if (failedRSS.length > 0) {
            console.log('‚ùå Failed RSS Feeds:');
            failedRSS.forEach(feed => {
                console.log(`   ‚Ä¢ ${feed.name}: ${feed.error}`);
                if (feed.suggestion) {
                    console.log(`     üí° ${feed.suggestion}`);
                }
            });
            console.log();
        }
        
        if (failedWebsites.length > 0) {
            console.log('‚ùå Failed Websites:');
            failedWebsites.forEach(site => {
                console.log(`   ‚Ä¢ ${site.name}: ${site.statusCode || 'Error'} - ${site.error}`);
                if (site.suggestion) {
                    console.log(`     üí° ${site.suggestion}`);
                }
            });
            console.log();
        }
    }

    showRecommendations() {
        console.log('ÔøΩÔøΩ RECOMMENDATIONS');
        console.log('==================\n');
        
        const { summary } = this.results;
        
        if (summary.overall.rate >= 80) {
            console.log('‚úÖ Source connectivity is excellent! Most sources are working properly.');
        } else if (summary.overall.rate >= 60) {
            console.log('‚ö†Ô∏è Source connectivity is fair. Some sources need attention.');
        } else {
            console.log('üî¥ Multiple source issues detected. Review and update source configurations.');
        }
        
        console.log('\nüìã Next Steps:');
        console.log('1. Update URLs for failed RSS feeds in src/services/rssFetcher.js');
        console.log('2. Update selectors for failed websites in getScrapingSources()');
        console.log('3. Test individual sources: node scripts/test-sources.js');
        console.log('4. Run a refresh: npm run refresh');
        
        console.log('\nüí° Tips:');
        console.log('‚Ä¢ For 404 errors: Check if the URL has changed on the website');
        console.log('‚Ä¢ For 403 errors: The site may be blocking automated requests');
        console.log('‚Ä¢ For timeout errors: Increase timeout or check network');
        console.log('‚Ä¢ Some sites change their structure - selectors may need updating');
    }
}

// Run test if called directly
if (require.main === module) {
    const tester = new SourceTester();
    tester.testAllSources().catch(error => {
        console.error('üí• Source testing failed:', error.message);
        process.exit(1);
    });
}

module.exports = SourceTester;

